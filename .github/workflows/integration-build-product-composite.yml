name: Build Packer images
on:
  workflow_call:
    inputs:
      product_name:
        required: true
        type: string
      debug_fleet_keep_alive:
        required: false
        type: boolean
      ros_distro:
        required: true
        type: string
      nightly_run_branch:
        required: false
        type: string
        default: "UNDEFINED"
      overwrite_slack_channel:
        required: false
        type: string
        default: "C050L85R6VC"
      docker_registry:
        required: false
        type: string
        default: "registry.hel.mov.ai"
      use_project_data_viewer:
        required: false
        type: boolean
        default: false
      fleet_ips:
        required: true
        type: string
      fleet_number_members:
        required: true
        type: number


    secrets:
      auto_commit_user:
        required: true
      auto_commit_mail:
        required: true
      auto_commit_pwd:
        required: true
      registry_user:
        required: true
      registry_password:
        required: true
      nexus_publisher_user:
        required: true
      nexus_publisher_password:
        required: true
      gh_token:
        required: true
      aws_key_id:
        required: true
      aws_secret_key_id:
        required: true
      slack_token_id:
        required: true
      ssh_pem_fleet_aws_vm:
        required: true
      proxmox_api_url:
        required: true
      proxmox_api_token_id:
        required: true
      proxmox_api_token_secret:
        required: true
      ssh_priv_key:
        required: true
      pdv_auth_token:
        required: false
      minio_key_id:
        required: false
      minio_secret_key_id:
        required: false

env:
  CI_INTEGRATION_SCRIPTS_VERSION: "2.2.0.15"
  MOBTEST_VERSION: "0.0.4.3"
  PACKAGE_DEPLOYER_VERSION: "1.0.0.26"
  GITHUB_API_USR: "OttoMation-Movai"
  AWS_ACCESS_KEY_ID: ${{ secrets.aws_key_id }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.aws_secret_key_id }}
  REGISTRY: ${{ inputs.docker_registry }}
  PUSH_REGISTRY: registry.cloud.mov.ai
  MID_REGISTRY: registry.hel.mov.ai
  USERSPACE_FOLDER_PATH: userspace
  REMOTE_WORKSPACE_PATH: workspace
  PROVISION_INFRA_REPO: "devops-tf-proxmox-fleet"
  PROVISION_INFRA_VERSION: "0.1.0-7"
  # slack channel movai-projects
  #SLACK_CHANNEL: ${{ inputs.overwrite_slack_channel }}
  # development slack channel
  SLACK_CHANNEL: "C05K2KF1UP8"
  PROJECT_DATA_VIEWER_API: "https://personal-7vf0v2cu.outsystemscloud.com/ProjectDataViewer5/rest/V1//CreateProject"
  MINIO_S3_URL: "https://s3.mov.ai"

jobs:
  Validate-boostrap-configs:
    runs-on: integration-pipeline
    container:
      image: registry.aws.cloud.mov.ai/devops/py-buildserver:latest
      credentials:
        username: ${{secrets.registry_user}}
        password: ${{secrets.registry_password}}
    outputs:
      slack_thread_id: ${{ fromJson(steps.send-message.outputs.slack-result).response.message.ts }}
    steps:
      - name: Checkout
        if: ${{ inputs.is_nightly_run == false }}
        uses: actions/checkout@v4

      - name: Nightly Checkout
        if: ${{ inputs.is_nightly_run }}
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.nightly_run_branch }}

      - name: Validate Manifest
        shell: bash
        run: |
          apt install -y yamllint
          yamllint product-manifest.yaml

      - name: Install CI Scripts
        shell: bash
        run: |
          python3 -m pip install pip --upgrade
          python3 -m pip install pyopenssl --upgrade
          python3 -m pip install integration-pipeline==$CI_INTEGRATION_SCRIPTS_VERSION --ignore-installed

      - name: Bootstraping simulator metadata
        run: |
          git config --global --add safe.directory $(pwd)
          git fetch
          git checkout origin/${GITHUB_REF#refs/heads/} -- product.version
          cat product.version
          rm -rf simulator_artifacts ci_artifacts

          merge_manifest_args=" --dependency_name products"
          merge_manifest_args="$merge_manifest_args --gh_api_user $GITHUB_API_USR"
          merge_manifest_args="$merge_manifest_args --gh_api_pwd ${{ secrets.auto_commit_pwd }}"
          merge_manifest_args="$merge_manifest_args --merge_sub_prod_dep_keys platform_config,platform_components"
          merge_manifest_args="$merge_manifest_args --merge_sub_prod_main_keys product_config,system_config"

          integration-pipeline merge_manifest_multi_dependency $merge_manifest_args 


      - name: raise
        run: |
          rm -rf simulator_artifacts ci_artifacts
          mkdir platform_configs
          integration-pipeline raise
          cp product.version ./platform_configs/product.version
          cp product-manifest.yaml ./platform_configs/product-manifest.yaml

      - name: Prepare slack variables
        if: always()
        id: pre_slack
        shell: bash
        run: |
          MESSAGE="CI: ${GITHUB_REPOSITORY} (${GITHUB_REF#refs/heads/}), build: $(cat product.version)(Attempt: #${{ github.run_attempt }}) is starting to be validated :construction: Details: https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          echo "msg=${MESSAGE}" >> $GITHUB_OUTPUT

      - name: Send Slack Message
        uses: archive/github-actions-slack@master
        id: send-message

        with:
          slack-function: send-message
          slack-bot-user-oauth-access-token: ${{ secrets.slack_token_id }}
          slack-channel: ${{ env.SLACK_CHANNEL }}
          slack-text: ${{ steps.pre_slack.outputs.msg }}

      - name: Stash raised_meta
        uses: actions/upload-artifact@v3
        with:
          name: raised_meta
          path: platform_configs/*
          retention-days: 5

  Build-Spawner:
    needs: [Validate-boostrap-configs]
    strategy:
      matrix:
        distro: ${{ fromJSON(inputs.ros_distro) }}
    runs-on: integration-pipeline
    outputs:
      raised_version: ${{ steps.pre_build.outputs.raised_version }}
      slack_thread_id: ${{ needs.Validate-boostrap-configs.outputs.slack_thread_id }}
    steps:
      - uses: rtCamp/action-cleanup@master
      - name: Checkout
        uses: actions/checkout@v3

      - name: Agent info
        run: |
          echo "public ip: $(curl ipinfo.io/ip)"
          echo "private ip: $(hostname -I | awk '{print $1}')"

      - name: Install CI Scripts
        shell: bash
        run: |
          python3 -m pip install pip --upgrade
          python3 -m pip install pyopenssl --upgrade
          python3 -m pip install integration-pipeline==$CI_INTEGRATION_SCRIPTS_VERSION --ignore-installed

      - name: unstash raised_meta
        uses: actions/download-artifact@v3
        with:
          name: raised_meta
          path: platform_configs

      - name: Generate product configs from manifest
        shell: bash
        run: |
          cp ./platform_configs/product.version product.version
          cp ./platform_configs/product-manifest.yaml product-manifest.yaml
          export PATH="$HOME/.local/bin:$PATH"
          cat product-manifest.yaml
          integration-pipeline generate_composite_meta_artifacts --manifest_platform_base_key "product_dependencies.products" --override_spawner ${{ inputs.product_name }}

      - name: Stash manifest
        uses: actions/upload-artifact@v3
        with:
          name: manifest
          path: product-manifest.yaml
          retention-days: 5

      - name: Lint docker image
        shell: bash
        run: |
          wget https://github.com/hadolint/hadolint/releases/download/v2.9.3/hadolint-Linux-x86_64
          chmod +x hadolint-Linux-x86_64
          ./hadolint-Linux-x86_64 docker/${{ matrix.distro }}/Dockerfile -t error

      - name: Login to ${{ env.REGISTRY }} Registry
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.registry_user }}
          password: ${{ secrets.registry_password }}
          registry: ${{ env.REGISTRY }}

      - name: Login to ${{ env.PUSH_REGISTRY }} Registry
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.registry_user }}
          password: ${{ secrets.registry_password }}
          registry: ${{ env.PUSH_REGISTRY }}

      - name: Login to ${{ env.MID_REGISTRY }} Registry
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.registry_user }}
          password: ${{ secrets.registry_password }}
          registry: ${{ env.MID_REGISTRY }}

      - name: Prepare docker build variables
        id: pre_build
        shell: bash
        run: |
          mkdir -p /tmp/ci_artifacts/dependency/

          integration-pipeline get_yml_value --file product-manifest.yaml --key product_dependencies.product_base.name --output_file /tmp/ci_artifacts/product_base_name.txt
          integration-pipeline get_yml_value --file product-manifest.yaml --key product_dependencies.product_base.version --output_file /tmp/ci_artifacts/product_base_version.txt

          integration-pipeline fetch_github_release_asset --asset_name product-manifest.yaml --repo $(cat /tmp/ci_artifacts/product_base_name.txt) --version $(cat /tmp/ci_artifacts/product_base_version.txt) --gh_api_user $GITHUB_API_USR --gh_api_pwd ${{ secrets.auto_commit_pwd }} --target_dir /tmp/ci_artifacts/dependency/

          integration-pipeline get_yml_value --file /tmp/ci_artifacts/dependency/product-manifest.yaml --key product_dependencies.platform_config.spawner_noetic.name --output_file /tmp/ci_artifacts/spawner_base_name.txt
          integration-pipeline get_yml_value --file /tmp/ci_artifacts/dependency/product-manifest.yaml --key product_dependencies.platform_config.spawner_noetic.version --output_file /tmp/ci_artifacts/spawner_base_version.txt

          cp /tmp/ci_artifacts ./ci_artifacts -r
          ls -la
          ls -la ci_artifacts
          echo "base_name=$(cat ci_artifacts/spawner_base_name.txt)" >> $GITHUB_OUTPUT
          echo "base_version=$(cat ci_artifacts/spawner_base_version.txt)" >> $GITHUB_OUTPUT
          echo "raised_version=$(cat product.version)" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: Docker build
        shell: bash
        run: |
          docker build --add-host ${{ env.REGISTRY }}:172.22.0.106 \
            --build-arg DOCKER_REGISTRY=${{ env.REGISTRY }} \
            --build-arg BASE_IMAGE=${{ steps.pre_build.outputs.base_name }} \
            --build-arg TAG=${{ steps.pre_build.outputs.base_version }} \
            --build-arg CI_SCRIPT_VERSION=${{ env.CI_INTEGRATION_SCRIPTS_VERSION }} \
            --file docker/${{ matrix.distro }}/Dockerfile \
            --platform linux/amd64 \
            --tag ${{ env.PUSH_REGISTRY }}/ci/${{ inputs.product_name }}-${{ matrix.distro }}:${{ steps.pre_build.outputs.raised_version }} \
            --pull \
            --progress=plain \
            --push .

      - name: Get current job id
        if: always()
        shell: bash
        id: job_info
        run: |
          sudo apt install jq -y
          job_id=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id}}/attempts/${{ github.run_attempt }}/jobs | jq -r '.jobs | .[0].id')
          job_html_url=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id}}/attempts/${{ github.run_attempt }}/jobs | jq -r '.jobs | map(select(.name | contains("${{ github.job }}"))) | .[0].html_url')
          echo "$job_id"
          echo "$job_html_url"
          echo "job_url=$job_html_url" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.gh_token }}

      - name: Prepare slack variables
        if: always()
        id: pre_slack_result
        run: |
          MESSAGE=":white_check_mark: ${{ github.job }} (Attempt: #${{ github.run_attempt }}) job passed"
          MESSAGE_ERR=":x: ${{ github.job }} (Attempt: #${{ github.run_attempt }}) job failed"
          echo "msg=${MESSAGE}" >> $GITHUB_OUTPUT
          echo "msg_error=${MESSAGE_ERR}\n  Details: ${{ steps.job_info.outputs.job_url }}" >> $GITHUB_OUTPUT

      - name: Slack message success
        uses: archive/github-actions-slack@master
        with:
          slack-function: send-message
          slack-bot-user-oauth-access-token: ${{ secrets.slack_token_id }}
          slack-channel: ${{ env.SLACK_CHANNEL }}
          slack-text: ${{ steps.pre_slack_result.outputs.msg }}
          slack-optional-thread_ts: ${{ needs.Validate-boostrap-configs.outputs.slack_thread_id }}

      - name: Slack message failure
        uses: archive/github-actions-slack@master
        if: failure()
        with:
          slack-function: send-message
          slack-bot-user-oauth-access-token: ${{ secrets.slack_token_id }}
          slack-channel: ${{ env.SLACK_CHANNEL }}
          slack-text: ${{ steps.pre_slack_result.outputs.msg_error }}
          slack-optional-thread_ts: ${{ needs.Validate-boostrap-configs.outputs.slack_thread_id }}


      - name: Stash robot_jsons_${{ matrix.distro }}
        uses: actions/upload-artifact@v3
        with:
          name: robot_jsons_${{ matrix.distro }}
          path: "*.json*"
          retention-days: 10

      - name: Docker cleanups
        if: always()
        shell: bash
        run: |
          docker system prune -f
          docker image prune --all -f

  Install-Robot:
    needs: [Build-Spawner]
    strategy:
      matrix:
        distro: ${{ fromJSON(inputs.ros_distro) }}
    runs-on: integration-pipeline
    outputs:
      slack_thread_id: ${{ needs.Build-Spawner.outputs.slack_thread_id }}

    steps:
      - uses: rtCamp/action-cleanup@master

      - name: Checkout
        uses: actions/checkout@v3

      - name: Agent info
        run: |
          echo "public ip: $(curl ipinfo.io/ip)"
          echo "private ip: $(hostname -I | awk '{print $1}')"

      - name: unstash raised_meta
        uses: actions/download-artifact@v3
        with:
          name: raised_meta
          path: .

      - name: unstash manifest
        uses: actions/download-artifact@v3
        with:
          name: manifest
          path: .

      - name: unstash robot_jsons_${{ matrix.distro }}
        uses: actions/download-artifact@v3
        with:
          name: robot_jsons_${{ matrix.distro }}
          path: .

      - name: Login to ${{ env.REGISTRY }} Registry
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.registry_user }}
          password: ${{ secrets.registry_password }}
          registry: ${{ env.REGISTRY }}

      - name: Login to ${{ env.PUSH_REGISTRY }} Registry
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.registry_user }}
          password: ${{ secrets.registry_password }}
          registry: ${{ env.PUSH_REGISTRY }}

      - name: Login to ${{ env.MID_REGISTRY }} Registry
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.registry_user }}
          password: ${{ secrets.registry_password }}
          registry: ${{ env.MID_REGISTRY }}

      - name: Docker load spawner image
        shell: bash
        run: |
          docker pull "${{ env.MID_REGISTRY }}/ci/${{ inputs.product_name }}-${{ matrix.distro }}:${{ needs.Build-Spawner.outputs.raised_version }}"
          docker tag "${{ env.MID_REGISTRY }}/ci/${{ inputs.product_name }}-${{ matrix.distro }}:${{ needs.Build-Spawner.outputs.raised_version }}" "${{ env.REGISTRY }}/qa/${{ inputs.product_name }}-${{ matrix.distro }}:${{ needs.Build-Spawner.outputs.raised_version }}"
          docker tag "${{ env.MID_REGISTRY }}/ci/${{ inputs.product_name }}-${{ matrix.distro }}:${{ needs.Build-Spawner.outputs.raised_version }}" "${{ env.PUSH_REGISTRY }}/qa/${{ inputs.product_name }}-${{ matrix.distro }}:${{ needs.Build-Spawner.outputs.raised_version }}"



      - name: Installation
        shell: bash
        run: |
          for robot in $(movai-cli robots list); do
            movai-cli robots stop $robot
            sleep 5
            movai-cli robots remove $robot
          done || true

          mkdir -p artifacts
          cp *.json artifacts/
          CONFIG_FILE_NAME="standalone-manager-${{ matrix.distro }}-template.json"
          mkdir -p userspace/models_database/ userspace/tugbot_ignition/

          export USERSPACE_FOLDER_PATH="$(pwd)/userspace"
          export PUBLIC_IP=$(hostname -I | awk '{print $1}')

          export PATH="$HOME/.local/bin:$PATH"
          integration-pipeline get_json_value --file $CONFIG_FILE_NAME.ci --key services_version --output_file movai_service_version
          integration-pipeline get_json_value --file $CONFIG_FILE_NAME.ci --key quickstart_version --output_file quickstart_version

          wget https://movai-scripts.s3.amazonaws.com/QuickStart_$(cat quickstart_version).bash
          chmod +x ./QuickStart_$(cat quickstart_version).bash
          ./QuickStart_$(cat quickstart_version).bash --apps $(cat movai_service_version) $CONFIG_FILE_NAME

          execution_status=$?
          exit $execution_status
          rm movai_service_version

      - name: Run mobtest
        shell: bash
        run: |
          container_id=$(docker ps --format '{{.Names}}' --filter "name=^spawner-.*")
          docker exec -t "$container_id" bash -c '
            set -e
            export PATH="$HOME/.local/bin:$PATH"
            python3 -m pip install -i https://artifacts.cloud.mov.ai/repository/pypi-integration/simple --extra-index-url https://pypi.org/simple mobtest==${{ env.MOBTEST_VERSION }} --ignore-installed
            mobtest proj /opt/ros/noetic/share/
            '
      - name: Collect Installed components
        if: always()
        shell: bash
        run: |
          container_id=$(docker ps -q -f "ancestor=$REGISTRY/qa/${{ inputs.product_name }}-${{ matrix.distro }}:$(cat product.version)")
          docker exec -t "$container_id" bash -c '
            set -e
            sudo apt update
            export PATH="$HOME/.local/bin:$PATH"
            python3 -m pip install -i https://artifacts.cloud.mov.ai/repository/pypi-integration/simple --extra-index-url https://pypi.org/simple movai-package-deployer==${{ env.PACKAGE_DEPLOYER_VERSION }} --ignore-installed
            package-deployer scan
            package-deployer scanAll
            ls -la /tmp

            {
                echo 'Annotation:*'
                echo 'Callback:*'
                echo 'Configuration:*'
                echo 'Flow:*'
                echo 'GraphicScene:*'
                echo 'Layout:*'
                echo 'Node:*'
                echo 'Package:*'
            } >> /tmp/manifest.txt
            mkdir /tmp/proj_metadata
            python3 -m tools.backup -p /tmp/proj_metadata/ -m /tmp/manifest.txt -a export -i

          ' || true
            docker cp $container_id:/tmp/deployable.dploy artifacts/${{ inputs.product_name }}-${{ matrix.distro }}-deployable.dploy
            docker cp $container_id:/tmp/undeployable.dploy artifacts/${{ inputs.product_name }}-${{ matrix.distro }}-3rdParty.dploy
            docker cp $container_id:/tmp/apt_packages.json artifacts/${{ inputs.product_name }}-${{ matrix.distro }}-apt_packages.json

            mkdir -p metadata_artifact tmp_meta
            docker cp $container_id:/tmp/proj_metadata/ ./
            tar cvzf ./metadata_artifact/metadata.tar.gz ./proj_metadata

            echo "$PUSH_REGISTRY/qa/${{ inputs.product_name }}-${{ matrix.distro }}:$(cat product.version)">artifacts/product-${{ matrix.distro }}.image.artifact
  
      - name: Get current job id
        if: always()
        shell: bash
        id: job_info
        run: |
          sudo apt install jq -y
          job_id=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id}}/attempts/${{ github.run_attempt }}/jobs | jq -r '.jobs | .[0].id')
          job_html_url=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id}}/attempts/${{ github.run_attempt }}/jobs | jq -r '.jobs | map(select(.name | contains("${{ github.job }}"))) | .[0].html_url')
          echo "$job_id"
          echo "$job_html_url"
          echo "job_url=$job_html_url" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.gh_token }}

      - name: Prepare slack variables
        if: always()
        id: pre_slack_result
        run: |
          MESSAGE=":white_check_mark: ${{ github.job }} (Attempt: #${{ github.run_attempt }}) job passed"
          MESSAGE_ERR=":x: ${{ github.job }} (Attempt: #${{ github.run_attempt }}) job failed"
          echo "msg=${MESSAGE}" >> $GITHUB_OUTPUT
          echo "msg_error=${MESSAGE_ERR}\n  Details: ${{ steps.job_info.outputs.job_url }}" >> $GITHUB_OUTPUT

      - name: Slack message success
        uses: archive/github-actions-slack@master
        with:
          slack-function: send-message
          slack-bot-user-oauth-access-token: ${{ secrets.slack_token_id }}
          slack-channel: ${{ env.SLACK_CHANNEL }}
          slack-text: ${{ steps.pre_slack_result.outputs.msg }}
          slack-optional-thread_ts: ${{ needs.Build-Spawner.outputs.slack_thread_id }}

      - name: Slack message failure
        uses: archive/github-actions-slack@master
        if: failure()
        with:
          slack-function: send-message
          slack-bot-user-oauth-access-token: ${{ secrets.slack_token_id }}
          slack-channel: ${{ env.SLACK_CHANNEL }}
          slack-text: ${{ steps.pre_slack_result.outputs.msg_error }}
          slack-optional-thread_ts: ${{ needs.Build-Spawner.outputs.slack_thread_id }}

      - name: Stash project metadata

        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: project_metadata
          path: metadata_artifact/*
          retention-days: 3

      - name: Stash deploy_artifacts_noetic
        uses: actions/upload-artifact@v3
        with:
          name: deploy_artifacts_noetic
          path: artifacts/*
          retention-days: 5

      - name: Remove robots
        if: always()
        shell: bash
        run: |
          for robot in $(movai-cli robots list); do
            movai-cli robots stop $robot
            sleep 5
            movai-cli robots remove $robot
          done || true

      - name: Docker cleanups
        if: always()
        shell: bash
        run: |
          docker system prune -f
          docker image prune --all -f

  Install-Heterogeneos-Fleet:
    needs: [Build-Spawner]
    strategy:
      matrix:
        distro: ${{ fromJSON(inputs.ros_distro) }}
    runs-on: integration-pipeline

    steps:
      - uses: rtCamp/action-cleanup@master

      - name: Checkout
        uses: actions/checkout@v3

      - name: Agent info
        run: |
          echo "public ip: $(curl ipinfo.io/ip)"
          echo "private ip: $(hostname -I | awk '{print $1}')"

      - name: unstash raised_meta
        uses: actions/download-artifact@v3
        with:
          name: raised_meta
          path: .

      - name: unstash manifest
        uses: actions/download-artifact@v3
        with:
          name: manifest
          path: .

      - name: unstash robot_jsons_${{ matrix.distro }}
        uses: actions/download-artifact@v3
        with:
          name: robot_jsons_${{ matrix.distro }}
          path: .


      - name: Install terraform
        shell: bash
        run: |
          wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
          sudo apt update && sudo apt install terraform -y
  
      - name: Setup terraform proxmox provisioner
        id: provision_infra_setup
        shell: bash
        run: |
          provision_infra_dir=provision_scripts
          provision_infra_version=0.0.1-38
          provision_infra_repo_name=devops-tf-proxmox-fleet

          rm -rf $provision_infra_dir
          export PATH="$HOME/.local/bin:$PATH"
          integration-pipeline fetch_by_tag --repo $provision_infra_repo_name --version $provision_infra_version --gh_api_user $GITHUB_API_USR --gh_api_pwd ${{ secrets.auto_commit_pwd }} --target_dir $provision_infra_dir
          ls -la $provision_infra_dir
          echo "target_dir=${provision_infra_dir}/hosts/generic/" >> $GITHUB_OUTPUT

      - name: Define Instance names
        id: infra_names
        shell: bash
        run: |
          branch=$(echo ${GITHUB_REF#refs/heads/} | sed "s;\.;-;g" )

          local_manager_prefix="ip-hgf-$branch-manager"
          local_worker_prefix="ip-$branch-worker"
          echo "$local_manager_prefix"
          echo "$local_worker_prefix"

          echo "manager_prefix=${local_manager_prefix}" >> $GITHUB_OUTPUT
          echo "worker_prefix=${local_worker_prefix}" >> $GITHUB_OUTPUT

      - name: Provision remote vms (Proxmox)
        working-directory: ${{ steps.provision_infra_setup.outputs.target_dir }}
        shell: bash
        run: |
          terraform init -backend-config="key=hel-fleet-${{ steps.infra_names.outputs.manager_prefix }}.tfstate"
          terraform plan
          terraform apply -auto-approve
        env:
          TF_VAR_number_agents: ${{ inputs.fleet_number_members }}
          TF_VAR_proxmox_api_url: "https://hel.mov.ai:8006/api2/json"
          TF_VAR_proxmox_api_token_id: ${{ secrets.proxmox_api_token_id }}
          TF_VAR_proxmox_api_token_secret: ${{ secrets.proxmox_api_token_secret }}
          TF_VAR_provision_ssh_pem: ${{ secrets.ssh_pem_fleet_aws_vm }}
          TF_VAR_ip_list: ${{ inputs.fleet_ips }}
          TF_VAR_proxmox_host: "hel"
          TF_VAR_vm_gateway: "172.22.0.1"
          TF_VAR_ip_mask: 24
          TF_VAR_bios: "seabios"
          TF_VAR_pool: "IP-Temp-VMs"
          TF_VAR_tags: "ip-fleet"

          TF_VAR_fleet_hosts_user: "devops"
          TF_VAR_template_name: "ubuntu-2004-cloudinit-template2"
          TF_VAR_fleet_manager_name: ${{ steps.infra_names.outputs.manager_prefix }}
          TF_VAR_fleet_manager_memory: 8192
          TF_VAR_template_name_no_gpu: "ubuntu-2004-cloudinit-template2"
          TF_VAR_fleet_worker_name_prefix: ${{ steps.infra_names.outputs.worker_prefix }}
          TF_VAR_fleet_worker_memory: 8192

      - name: Prepare Devops provisioning slack message
        if: always()
        id: pre_slack_infra
        run: |
          MESSAGE_ERR=":x: CI: ${GITHUB_REPOSITORY}, (${GITHUB_REF#refs/heads/}), build: $(cat product.version) is being impacted by an infrastructural issue. \
          Provisioning of fleet infrastructure failed. Please take a look! \
          Details: https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          echo "msg_error=${MESSAGE_ERR}" >> $GITHUB_OUTPUT

      - name: Slack message failure
        if: failure()
        uses: slackapi/slack-github-action@v1.23.0
        with:
          channel-id: "G0102LEV1CL"
          slack-message: ${{ steps.pre_slack_infra.outputs.msg_error }}
        env:
          SLACK_BOT_TOKEN: ${{ secrets.slack_token_id }}

      - name: Wait for machines getting up
        id: wait_for_machines
        shell: bash
        run: |
          function ensure_agent_up(){
            vm_ip=$1
            i="0"
            max=15
            success=1
            while [ $success -ne 0 ]
            do
            echo "Checking if $vm_ip is reachable ($i/$max)"
            ping -c1 $vm_ip &>/dev/null
            success=$?

            if [ $i -lt $max ]
            then
              i=$[$i+1]
            else
              echo "Timeout waiting for $vm_ip"
              exit 2
            fi

            sleep 2
            done

          }
          echo "${{ secrets.ssh_pem_fleet_aws_vm }}" > ~/.ssh/aws_slave.pem
          sudo chmod 600 ~/.ssh/aws_slave.pem

          stripped_ips=$(echo ${{ inputs.fleet_ips }} | sed "s;\[;;g" | sed "s;];;g" | sed "s; ;;g")
          touch ~/.ssh/known_hosts
          sudo chmod 600 ~/.ssh/known_hosts
          IFS=',' read -r -a stripped_ips_arr <<< $stripped_ips
          manager_ip=${stripped_ips_arr[0]}
          echo $manager_ip
          echo "manager_ip=${manager_ip}" >> $GITHUB_OUTPUT
          echo "manager_ssh_conn_string=devops@${manager_ip}" >> $GITHUB_OUTPUT
          for ip in "${stripped_ips_arr[@]}"
          do
            ensure_agent_up $ip
            ssh-keygen -f ~/.ssh/known_hosts -R $ip
            ssh-keyscan -H $ip >> ~/.ssh/known_hosts
          done

      - name: Docker load manager spawner (Remote)
        shell: bash
        run: |
          ssh_conn_string=${{ steps.wait_for_machines.outputs.manager_ssh_conn_string }}
          ssh $ssh_conn_string -i ~/.ssh/aws_slave.pem -o StrictHostKeyChecking=no '
            sudo cp /etc/hosts /etc/hosts.bak
            echo '172.22.0.106 registry.hel.mov.ai' | sudo tee -a /etc/hosts
            docker login ${{ env.REGISTRY }} -u ${{ secrets.registry_user }} -p ${{ secrets.registry_password }}
            docker login ${{ env.PUSH_REGISTRY }} -u ${{ secrets.registry_user }} -p ${{ secrets.registry_password }}
            docker login ${{ env.MID_REGISTRY }} -u ${{ secrets.registry_user }} -p ${{ secrets.registry_password }}

            docker pull "${{ env.MID_REGISTRY }}/ci/${{ inputs.product_name }}-${{ matrix.distro }}:${{ needs.Build-Spawner.outputs.raised_version }}"
            docker tag "${{ env.MID_REGISTRY }}/ci/${{ inputs.product_name }}-${{ matrix.distro }}:${{ needs.Build-Spawner.outputs.raised_version }}" "${{ env.REGISTRY }}/qa/${{ inputs.product_name }}-${{ matrix.distro }}:${{ needs.Build-Spawner.outputs.raised_version }}"
            docker tag "${{ env.MID_REGISTRY }}/ci/${{ inputs.product_name }}-${{ matrix.distro }}:${{ needs.Build-Spawner.outputs.raised_version }}" "${{ env.PUSH_REGISTRY }}/qa/${{ inputs.product_name }}-${{ matrix.distro }}:${{ needs.Build-Spawner.outputs.raised_version }}"
          '

      - name: Setup ansible installation
        id: ansible_install_setup
        shell: bash
        run: |
          install_key=ansible_deploy

          rm -f /tmp/target_dir.txt /tmp/version.txt /tmp/repo_name.txt
          export PATH="$HOME/.local/bin:$PATH"
          integration-pipeline get_yml_value --file product-manifest.yaml --key product_components.installation.$install_key.target_dir --output_file /tmp/target_dir.txt
          integration-pipeline get_yml_value --file product-manifest.yaml --key product_components.installation.$install_key.version --output_file /tmp/version.txt
          integration-pipeline get_yml_value --file product-manifest.yaml --key product_components.installation.$install_key.name --output_file /tmp/repo_name.txt
          install_infra_dir=$(cat /tmp/target_dir.txt)
          install_infra_version=$(cat /tmp/version.txt)
          install_infra_repo_name=$(cat /tmp/repo_name.txt)

          rm -rf $install_infra_repo_name
          integration-pipeline fetch_by_tag --repo $install_infra_repo_name --version $install_infra_version --gh_api_user $GITHUB_API_USR --gh_api_pwd ${{ secrets.auto_commit_pwd }} --target_dir $install_infra_dir
          ls -la $install_infra_dir
          echo "target_dir=${install_infra_dir}" >> $GITHUB_OUTPUT
  
      - name: Ansible install platform
        id: ansible_install_platform
        working-directory: ${{ steps.ansible_install_setup.outputs.target_dir }}
        shell: bash
        run: |
          
          cp ../${{ steps.provision_infra_setup.outputs.target_dir }}/hosts hosts
          cp -r ../*.json ./templates/fleet/
          cp ../product-manifest.yaml ./templates/fleet/product-manifest.yaml
          cat hosts
          ./fleet_install.sh setup --product-artifacts ./templates/fleet/ -i hosts -m install -v 2.6.0-9
        env:
          GITHUB_USER: ${{ env.GITHUB_API_USR }}
          GITHUB_TOKEN: ${{ secrets.auto_commit_pwd }}

      - name: Collect Installed components
        if: always()
        shell: bash
        run: |
            echo "PLACEHOLDER"
  
      - name: Get current job id
        if: always()
        shell: bash
        id: job_info
        run: |
          sudo apt install jq -y
          job_id=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id}}/attempts/${{ github.run_attempt }}/jobs | jq -r '.jobs | .[0].id')
          job_html_url=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id}}/attempts/${{ github.run_attempt }}/jobs | jq -r '.jobs | map(select(.name | contains("${{ github.job }}"))) | .[0].html_url')
          echo "$job_id"
          echo "$job_html_url"
          echo "job_url=$job_html_url" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.gh_token }}

      - name: Prepare slack variables
        if: always()
        id: pre_slack_result
        run: |
          MESSAGE=":white_check_mark: ${{ github.job }} (Attempt: #${{ github.run_attempt }}) job passed"
          MESSAGE_ERR=":x: ${{ github.job }} (Attempt: #${{ github.run_attempt }}) job failed"
          echo "msg=${MESSAGE}" >> $GITHUB_OUTPUT
          echo "msg_error=${MESSAGE_ERR}\n  Details: ${{ steps.job_info.outputs.job_url }}" >> $GITHUB_OUTPUT

      - name: Slack message success
        uses: archive/github-actions-slack@master
        with:
          slack-function: send-message
          slack-bot-user-oauth-access-token: ${{ secrets.slack_token_id }}
          slack-channel: ${{ env.SLACK_CHANNEL }}
          slack-text: ${{ steps.pre_slack_result.outputs.msg }}
          slack-optional-thread_ts: ${{ needs.Build-Spawner.outputs.slack_thread_id }}

      - name: Slack message failure
        uses: archive/github-actions-slack@master
        if: failure()
        with:
          slack-function: send-message
          slack-bot-user-oauth-access-token: ${{ secrets.slack_token_id }}
          slack-channel: ${{ env.SLACK_CHANNEL }}
          slack-text: ${{ steps.pre_slack_result.outputs.msg_error }}
          slack-optional-thread_ts: ${{ needs.Build-Spawner.outputs.slack_thread_id }}

      - name: Teardown remote vms (Proxmox)
        working-directory: ${{ steps.provision_infra_setup.outputs.target_dir }}
        if: ${{ ( !inputs.debug_fleet_keep_alive && success() ) || cancelled() || ( !inputs.debug_fleet_keep_alive && failure() ) }}
        shell: bash
        run: terraform destroy -auto-approve
        env:
          TF_VAR_number_agents: ${{ inputs.fleet_number_members }}
          TF_VAR_proxmox_api_url: "https://hel.mov.ai:8006/api2/json"
          TF_VAR_proxmox_api_token_id: ${{ secrets.proxmox_api_token_id }}
          TF_VAR_proxmox_api_token_secret: ${{ secrets.proxmox_api_token_secret }}
          TF_VAR_provision_ssh_pem: ${{ secrets.ssh_pem_fleet_aws_vm }}
          TF_VAR_ip_list: ${{ inputs.fleet_ips }}
  
      - name: Stash project metadata
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: project_metadata
          path: metadata_artifact/*
          retention-days: 3

      - name: Stash deploy_artifacts_noetic
        uses: actions/upload-artifact@v3
        with:
          name: deploy_artifacts_noetic
          path: artifacts/*
          retention-days: 5

      - name: Remove robots
        if: always()
        continue-on-error: true
        shell: bash
        run: |
          for robot in $(movai-cli robots list); do
            movai-cli robots stop $robot
            sleep 5
            movai-cli robots remove $robot
          done || true

      - name: Docker cleanups
        if: always()
        continue-on-error: true
        shell: bash
        run: |
          docker system prune -f
          docker image prune --all -f

  publish:
    needs: [Install-Robot, Install-Heterogeneos-Fleet]
    runs-on: integration-pipeline
    steps:
      - uses: rtCamp/action-cleanup@master

      - name: Checkout
        uses: actions/checkout@v3

      - name: Agent info
        run: |
          echo "public ip: $(curl ipinfo.io/ip)"
          echo "private ip: $(hostname -I | awk '{print $1}')"

      - name: unstash raised_meta
        uses: actions/download-artifact@v3
        with:
          name: raised_meta
          path: platform_configs

      - name: unstash deploy_artifacts_noetic
        uses: actions/download-artifact@v3
        with:
          name: deploy_artifacts_noetic
          path: artifacts

      - name: unstash manifest
        uses: actions/download-artifact@v3
        with:
          name: manifest
          path: .

      - name: Install CI Scripts
        shell: bash
        run: |
          python3 -m pip install pip --upgrade
          python3 -m pip install pyopenssl --upgrade
          python3 -m pip install integration-pipeline==$CI_INTEGRATION_SCRIPTS_VERSION --ignore-installed

      - name: Install Package Deployer
        shell: bash
        run: python3 -m pip install movai-package-deployer==$PACKAGE_DEPLOYER_VERSION --ignore-installed

      - name: Login to ${{ env.MID_REGISTRY }} Registry
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.registry_user }}
          password: ${{ secrets.registry_password }}
          registry: ${{ env.MID_REGISTRY }}

      - name: Login to ${{ env.PUSH_REGISTRY }} Registry
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.registry_user }}
          password: ${{ secrets.registry_password }}
          registry: ${{ env.PUSH_REGISTRY }}


      - name: Publish and create release
        id: bump
        shell: bash
        run: |
          git config --global --add safe.directory $(pwd)
          git config --global user.name '${{ secrets.auto_commit_user }}'
          git config --global user.email '${{ secrets.auto_commit_mail }}'
          git config --global user.password ${{ secrets.auto_commit_pwd }}

          cp ./platform_configs/product.version product.version
          cp ./platform_configs/product-manifest.yaml product-manifest.yaml
          mkdir -p deployment_artifacts

          export PATH="$HOME/.local/bin:$PATH"

          ls -la
          mkdir -p pkgs_deployable
          cp artifacts/*deployable.dploy pkgs_deployable
          package-deployer join --dploy_workspace "$(pwd)/pkgs_deployable"
          mv "$(pwd)/pkgs_deployable/merged.dploy" deployment_artifacts/deployable.dploy

          mkdir -p pkgs_undeployable
          cp artifacts/*3rdParty.dploy pkgs_undeployable
          package-deployer join --dploy_workspace "$(pwd)/pkgs_undeployable"
          mv "$(pwd)/pkgs_undeployable/merged.dploy" deployment_artifacts/3rdParty.dploy

          rm -rf pkgs_deployable pkgs_undeployable

          cp artifacts/*.json deployment_artifacts
          cp ./artifacts/product-noetic.image.artifact deployment_artifacts/product.image.artifact
          cp deployment_artifacts/product.image.artifact ./

          SAVEIFS=$IFS
          IFS=$'\n'
          images=($(cat product.image.artifact))
          IFS=$SAVEIFS   # Restore original IFS

          for image in "${images[@]}"
          do
            source=$(echo $image | sed "s-/qa/-/ci/-g" |  sed "s-${{ env.PUSH_REGISTRY }}-${{ env.MID_REGISTRY }}-g" )
            target=$(echo $image | sed "s-${{ env.MID_REGISTRY }}-${{ env.PUSH_REGISTRY }}-g" )
            docker pull $source
            echo "tagging $source as $target"
            docker tag $source $target
            docker push $target
          done

          cat product-manifest.yaml
          cp product-manifest.yaml deployment_artifacts

          product_version=$(cat product.version)
          # danger zone. Everything will be deleted.
          git restore product.version
          git restore product-manifest.yaml
          git pull
          echo "$product_version" > product.version

          git add product.version
          git commit -m "[skip actions] Automatic Raise"

          echo "version=${product_version}" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.gh_token }}

      - name: Prepare raise variables
        id: pre_raise
        run: |
          #echo ::set-output name=branch::${GITHUB_REF#refs/heads/}
          echo "branch=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT

      - name: Raise App version
        uses: CasperWA/push-protected@v2.14.0
        with:
          token: ${{ secrets.auto_commit_pwd }}
          branch: ${{ steps.pre_raise.outputs.branch }}
          unprotect_reviews: true

      - name: Github Publish
        shell: bash
        run: |
          commit_hash=$(git log --format="%H" -n 1)
          product_version=$(cat product.version)
          gh release create -p --generate-notes --target "$commit_hash" -t "${{ inputs.product_name }} $product_version" $product_version
          # add all files in the deployment_artifacts folder
          find deployment_artifacts -type f -exec gh release upload $product_version {} \;
        env:
          GITHUB_TOKEN: ${{ secrets.gh_token }}

      - name: Update release notes
        shell: bash
        run: |
          # release version
          product_version=$(cat product.version)

          # get existent release body
          ORIGINAL_RN=$(gh release view "${product_version}" --json body | jq -r .body)
          echo -e "ORIGINAL_RN:\n ${ORIGINAL_RN}"

          # get release PRs
          PRS=$(echo "${ORIGINAL_RN}" | sed -rn "s/.* by @.* in https:\/\/github\.com\/${{ github.repository_owner }}\/${{ github.event.repository.name }}\/pull\/([0-9]+).*/\1/p" | tr '\n' ' ')
          # change to array
          PRS=($PRS)
          echo "Found the following PRs: ${PRS[@]}"

          # new release notes file
          rm -rf notes.txt

          # What's Changed - with info from PRs
          echo "## What's Changed" >> notes.txt

          if [ ${#PRS[@]} -eq 0 ]; then
              # no PRs exist
              echo "No relevant changes." >> notes.txt
          else
              # PRs exist
              for pr in "${PRS[@]}"; do
                  gh pr view "${pr}" --json body | jq -r .body >> notes.txt
              done
          fi
          echo "" >> notes.txt

          # PRs
          echo "## PRs" >> notes.txt
          if [ ${#PRS[@]} -eq 0 ]; then
              # no PRs exist
              echo "No PRs." >> notes.txt
          else
              # PRs exist
              echo "${ORIGINAL_RN}" | grep "\* .* by @.* in https://github.com/${{ github.repository_owner }}/" >> notes.txt
          fi
          echo "" >> notes.txt

          ## Diff
          echo "## Diff" >> notes.txt
          echo "${ORIGINAL_RN}" | grep "\*\*Full Changelog\*\*" >> notes.txt

          # set new release notes
          gh release edit "${product_version}" --notes-file notes.txt
        env:
          GITHUB_TOKEN: ${{ secrets.gh_token }}

      - name: Prepare slack variables
        if: always()
        id: pre_slack
        shell: bash
        run: |
          MESSAGE=":white_check_mark: CI: ${GITHUB_REPOSITORY} (${GITHUB_REF#refs/heads/}), build: $(cat product.version) (Attempt: #${{ github.run_attempt }}) is stable :sunny: Details: https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          echo "msg=$MESSAGE" >> $GITHUB_OUTPUT

      - name: Slack message
        uses: archive/github-actions-slack@master
        with:
          slack-function: update-message
          slack-bot-user-oauth-access-token: ${{ secrets.slack_token_id }}
          slack-channel: ${{ env.SLACK_CHANNEL }}
          slack-update-message-text: ${{ steps.pre_slack.outputs.msg }}
          slack-update-message-ts: ${{ needs.Install-Robot.outputs.slack_thread_id }}

  Run-Status:
    runs-on: ubuntu-20.04
    needs: [publish, Validate-boostrap-configs]
    if: ${{ always() && ( needs.publish.result == 'failure' || needs.publish.result == 'cancelled' || needs.publish.result == 'skipped' ) }}
    steps:

      - name: unstash raised_meta
        uses: actions/download-artifact@v3
        with:
          name: raised_meta
          path: platform_configs

      - name: Copy product configs
        shell: bash
        run: |
          cp ./platform_configs/product.version product.version
          cp ./platform_configs/product-manifest.yaml product-manifest.yaml

      - name: Prepare slack variables
        id: pre_slack
        shell: bash
        run: |
          MESSAGE_ERR=":x: CI: ${GITHUB_REPOSITORY}, (${GITHUB_REF#refs/heads/}), build: $(cat product.version) (Attempt: #${{ github.run_attempt }}) is unstable (or canceled) :rain_cloud: Details: https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          echo "msg_error=${MESSAGE_ERR}" >> $GITHUB_OUTPUT

      - name: Slack message
        uses: archive/github-actions-slack@master
        with:
          slack-function: update-message
          slack-bot-user-oauth-access-token: ${{ secrets.slack_token_id }}
          slack-channel: ${{ env.SLACK_CHANNEL }}
          slack-update-message-text: ${{ steps.pre_slack.outputs.msg_error }}
          slack-update-message-ts: ${{ needs.Validate-boostrap-configs.outputs.slack_thread_id }}
